#!/usr/bin/env python
# vim: set noci ai ts=4 sts=4 sw=4 et fileencoding=utf-8:
#
# TODO:
# http://therning.org/magnus/archives/57 (install schemas)

# Suppress hashlib warnings.
import warnings
warnings.filterwarnings("ignore")

import base64
import cgi
import datetime
import feedparser
import json
import os
import pango
import random
import re
import sys
import threading
import time
import traceback
import urllib
import urllib2
import urlparse
import webbrowser
import xmpp
import yaml
import Queue

import gobject
import gtk
import pygtk

try:
    import pynotify
    HAVE_NOTIFY = True
except:
    HAVE_NOTIFY = False

import tmradio.audio

VERSION = '0.12'
USE_THREADING = False

# Global kill switch.
shutting_down = False

def is_url(text):
    parts = text.split(':')
    if not parts[0] in ('http', 'https', 'ftp', 'mailto'):
        return False
    if parts[0] == 'mailto':
        return '@' in parts[1]
    return parts[1].startswith('//')

def fetch(url):
    """Returns contents of a web resource."""
    try:
        res = urllib2.urlopen(urllib2.Request(url))
        if res is None:
            print >>sys.stderr, 'Could not fetch', url
            return None
        return res.read()
    except Exception, e:
        print >>sys.stderr, 'Could not fetch %s: %s' % (url, e)
        print >>sys.stderr, traceback.format_exc(e)

class YamlConfig:
    """YAML interface."""
    def __init__(self):
        self.filename = os.path.expanduser('~/.tmradio-client.yaml')
        if os.path.exists(self.filename):
            self.data = yaml.load(open(self.filename, 'rb').read())
        else:
            self.data = {}

    def save(self):
        dump = yaml.dump(self.data)
        exists = os.path.exists(self.filename)
        f = open(self.filename, 'wb')
        f.write(dump.encode('utf-8'))
        f.close()
        if not exists:
            os.chmod(self.filename, 0600)

    def get(self, key, default=None):
        if self.data.has_key(key):
            return self.data[key]
        return default

    def get_jabber_id(self):
        return self.get('jabber_id')

    def set_jabber_id(self, value):
        self.data['jabber_id'] = value

    def get_jabber_password(self):
        return base64.b64decode(self.get('jabber_password'))

    def set_jabber_password(self, value):
        self.data['jabber_password'] = base64.b64encode(value)

    def get_debug(self):
        return self.get('debug', '--debug' in sys.argv)

    def get_jabber_bot(self):
        return self.get('jabber_bot', 'robot@tmradio.net')

    def set_jabber_bot(self, value):
        self.data['jabber_bot'] = value

    def get_jabber_chat_room(self):
        return self.get('jabber_chat_room', 'tmradio@conference.jabber.ru')

    def set_jabber_chat_room(self, value):
        self.data['jabber_chat_room'] = value

    def get_jabber_chat_nick(self, guess=False):
        nick = self.get('jabber_chat_nick')
        if not nick and guess:
            nick = self.get_jabber_id().split('@')[0]
        return nick

    def set_jabber_chat_nick(self, value):
        self.data['jabber_chat_nick'] = value

    def get_stream_uri(self):
        return self.get('stream_uri', 'http://stream.tmradio.net:8180/live.mp3')

    def set_stream_uri(self, value):
        self.data['stream_uri'] = value

    def get_twitter_search(self):
        return self.get('twitter_search', '#tmradio')

    def set_twitter_search(self, value):
        self.data['twitter_search'] = value


class Jabber:
    """Simple jabber client.

    Understands some ardj replies and supports MUC.  All interfecence
    communication is serialized using incoming and outgoing queues, so it's
    thread safe.
    """

    PING_FREQUENCY = 60 # seconds
    PING_TIMEOUT = 5 # seconds

    def __init__(self, gui):
        self.gui = gui
        self.config = gui.config
        self.jid = None
        self.cli = None
        self.roster = None
        self.bot_jid = None
        self.chat_jid = None
        # Outgoing commands, added via post_message().
        self.out_queue = Queue.Queue()
        # Incoming commands, accessible via get_messages().
        self.in_queue = Queue.Queue()
        # RegExp for parsing the status line
        self.np_re = re.compile(u'^«(.+)» by (.+) — #(\d+) ♺(\d+) ⚖(\S+) Σ(\d+)[^@]+(.+)$')
        # RegExp for parsing the SHOW command (extracts pro/con lists only).
        self.show_re = re.compile(u'.* #(\d+).*length=(\d+)s.*editable=(True|False).*last_played=(\d+).* Pro: (.+), contra: (.+)\.$')
        # Status.
        self.last_track_id = None
        self.chat_active = False
        self.chat_my_name = None
        self.is_shutting_down = False
        self.reconnect_time = 0
        self.last_ping_ts = 0

        if USE_THREADING:
            self.worker = threading.Thread()
            self.worker.run = self._thread_worker
            self.worker.start()

    def post_message(self, text, chat=False, special=False):
        """Send a message.

        The message is added to the outgoing queue and will be processed asap.
        If chat is set, the message is sent to the chat room.  If special is
        set, the message is treated as a command to the jabber client and must
        be one of: connect, disconnect, join, leave.
        """
        self.out_queue.put((text, chat, special))

    def post_replies(self, replies):
        self.in_queue.put(replies)

    def fetch_replies(self):
        rep = []
        while not self.in_queue.empty():
            rep.append(self.in_queue.get())
        return rep

    def is_connected(self):
        return self.cli is not None

    def _connect(self):
        """Connects to the jabber server."""
        jid = self.config.get_jabber_id()
        password = self.config.get_jabber_password()
        if not jid or not password:
            self._log('disabled: jid/password not set.')
            return False

        self.jid = xmpp.protocol.JID(jid)
        if self.config.get_debug():
            cli = xmpp.Client(self.jid.getDomain())
        else:
            cli = xmpp.Client(self.jid.getDomain(), debug=[])

        res = cli.connect(proxy=self._get_proxy_settings())
        if not res:
            self._log('could not connect to %s.' % self.jid.getDomain())
            return False

        res = cli.auth(self.jid.getNode(), password, 'tmclient/')
        if not res:
            self._log('could not authorize with the server.')
            self.post_replies(('auth-error', ))
            return False

        self._log('connected to %s.' % self.jid.getDomain())
        self.last_ping_ts = time.time()

        self.cli = cli
        self.cli.sendInitPresence()
        self.roster = self.cli.Roster.getRoster()
        self.cli.RegisterHandler('message', self._on_message)
        self.cli.RegisterHandler('presence', self._on_presence)

        self.bot_jid = self.config.get_jabber_bot()
        self._join_chat_room()
        self._check_roster()
        return True

    def _get_proxy_settings(self):
        if not os.environ.has_key('http_proxy'):
            return None
        url = urlparse.urlparse(os.environ['http_proxy'])
        if not url.netloc:
            return None
        return { 'host': url.hostname, 'port': url.port or 80 }

    def _check_roster(self):
        """Checks whether we have the bot on our roster."""
        know = False
        for contact in self.roster.getItems():
            if contact == self.bot_jid:
                know = True
        if not know:
            self._log('need to make friends with %s' % self.bot_jid)
            msg = xmpp.Presence(to=self.bot_jid, typ='subscribe', status=u'Hello, I\'m using tmradio-client/' + VERSION)
            self.cli.send(msg)

    def _join_chat_room(self, suffix=None):
        """Joins you to the chat room."""
        if self.chat_active:
            self._log('double chat join prevented.')
            return
        self.chat_jid = self.config.get_jabber_chat_room()
        nick = self.config.get_jabber_chat_nick()
        if not nick:
            nick = self.jid.getStripped().split('@')[0]
        if suffix is not None:
            nick += suffix
        nick = nick.replace('%R', str(random.randrange(1111, 9999)))
        self.cli.send(xmpp.Presence(to=u'/'.join((self.chat_jid, nick))))
        self.chat_my_name = nick

    def _leave_chat_room(self):
        """Removes you from the chat room."""
        if not self.chat_my_name or not self.chat_active:
            self._log('trying to leave chat while not there')
        else:
            self._log('leaving the chat room.')
            msg = xmpp.Presence()
            msg.setTo(u'/'.join((self.chat_jid, self.chat_my_name)))
            msg.setType('unavailable')
            self.cli.send(msg)

    def _on_message(self, conn, msg):
        """Process chat and group chat messages."""
        self.last_ping_ts = time.time()
        if msg.getType() == 'groupchat':
            parts = unicode(msg.getFrom()).split('/')
            if len(parts) < 2:
                print msg
            else:
                nick = unicode(msg.getFrom()).split('/')[1]
                self.post_replies([
                    ('chat', msg.getBody(), nick, self._get_msg_ts(msg)),
                ])
            return

        elif msg.getFrom().getStripped() == self.bot_jid:
            text = msg.getBody()
            if not text:
                self._log('empty message received: %s' % msg)
                return
            if text.startswith('{'):
                data = json.loads(text)
                keys = { 'vote': 'track_vote', 'editable': 'track_editable', 'length': 'track_length', 'last_played': 'track_started_on', 'labels': 'track_labels', 'artist': 'track_artist', 'title': 'track_title', 'id': 'track_id' }
                replies = []
                for key in data:
                    value = data[key]
                    if keys.has_key(key):
                        key = keys[key]
                    replies.append(('set', key, value))
                self.post_replies(replies)
                return
        self._log('unhandled message: %s' % msg.getBody())

    def _get_msg_ts(self, msg):
        delay = msg.getTag('delay')
        if not delay:
            return None
        if not 'stamp' in delay.attrs:
            return None
        return datetime.datetime.strptime(delay.attrs['stamp'][:19], '%Y-%m-%dT%H:%M:%S')

    def _on_presence(self, conn, msg):
        """Process incoming presences."""
        self.last_ping_ts = time.time()
        sender = msg.getFrom()
        if self.bot_jid == sender.getStripped():
            self._on_bot_presence(msg)

        # Nickname taken in the chat room, append a random number.
        elif sender.getStripped() == self.config.get_jabber_chat_room():
            self._check_nickname_taken(sender, msg)

            replies = []
            myself = sender.getResource() == self.chat_my_name
            if msg.getType() == 'unavailable':
                replies.append(('part', sender.getResource()))
                if myself:
                    replies.append(('left', ))
                    self.chat_active = False
            else:
                replies.append(('join', sender.getResource()))
                if myself:
                    replies.append(('joined', ))
                    self.chat_active = True
            if len(replies):
                self.post_replies(replies)

    def _on_bot_presence(self, msg):
        if msg.getType() == 'unavailable':
            self.post_replies(('offline', ))
            return

        match = self.np_re.match(msg.getStatus() or '')
        if match:
            title, artist, track_id, count, weight, listeners, tags = match.groups()
            tags = [x.lstrip('@').strip() for x in tags.split(u' ')]
            self.post_replies([
                ('set', 'track_id', track_id),
                ('set', 'track_artist', artist),
                ('set', 'track_title', title),
                ('set', 'track_playcount', count),
                ('set', 'track_weight', weight),
                ('set', 'track_labels', tags),
                ('set', 'track_listeners', int(listeners)),
            ])
            # Status changed because somebody added labels or voted.  Our
            # vote did not change, no need to request it.
            if track_id != self.last_track_id:
                self.post_message('dump ' + track_id)
                self.last_track_id = track_id
        else:
            print msg
            self._log('bot status not understood: %s' % msg.getStatus())

    def _check_nickname_taken(self, sender, msg):
        er = msg.getTag('error')
        if er and er.attrs['code'] == '409':
            self.post_replies([
                ('chat', er.getTag('text').getCDATA(), sender.getResource()),
            ])
            self.chat_my_name = None
            self._join_chat_room(suffix=' (%R)')

    def _thread_worker(self):
        while not self.is_shutting_down:
            self.process_queue(1)

    def process_queue(self, timeout=0):
        if self.cli:
            res = self.cli.Process(timeout)
            if res == 0 or res is None:
                self._on_disconnected()
            self.ping_server()
        elif time.time() > self.reconnect_time:
            self.reconnect_time = int(time.time()) + 5
            self.post_message('connect', special=True)
        elif timeout:
            time.sleep(timeout) # prevent spinlocks
        while not self.out_queue.empty():
            text, chat, special = self.out_queue.get()
            self._process_message(text, chat, special)

    def ping_server(self):
        """Pings the server, reconnects on timeout."""
        now = time.time()
        if now - self.last_ping_ts < self.PING_FREQUENCY:
            return False
        self._log('pinging the server')
        self.last_ping_ts = now
        ping = xmpp.Protocol('iq',typ='get',payload=[xmpp.Node('ping',attrs={'xmlns':'urn:xmpp:ping'})])
        try:
            res = self.cli.SendAndWaitForResponse(ping, self.PING_TIMEOUT)
            if res is None:
                self._log('ping timeout')
                self._on_disconnected()
        except IOError, e:
            self._log('error pinging the server:')
            self._on_disconnected()
        return True

    def _process_message(self, text, chat=False, special=False):
        self._log('processing message: text="%s" chat=%s special=%s' % (text, chat, special))

        if special:
            if text == 'connect':
                if not self.cli:
                    self._connect()
            elif text == 'leave':
                self._leave_chat_room()
            elif text == 'join':
                if not self.cli:
                    self._connect()
                if self.cli:
                    self._join_chat_room()
            elif text == 'quit':
                self.is_shutting_down = True
                gtk.main_quit() # FIXME: what if we're not connected?
            else:
                self._log('^^^ unknown command.')
        elif chat:
            msg = xmpp.protocol.Message(body=text)
            msg.setTo(self.chat_jid)
            msg.setType('groupchat')
            self.cli.send(msg)
            self._log('sent to chat: %s' % text)
        else:
            msg = xmpp.protocol.Message(body=text)
            msg.setTo(self.bot_jid)
            msg.setType('chat')
            self.cli.send(msg)
            self._log('sent to bot: %s' % text)

    def _log(self, message):
        print >>sys.stderr, 'jabber:', message

    def _on_disconnected(self):
        self._log('disconnected from the server, reconnecting in 5 seconds.')
        self.cli = None
        self.chat_active = False
        self.chat_my_name = None
        self.post_replies([('left', ), ('disconnected', )])
        self.reconnect_time = int(time.time()) + 5


class TwitterClientThread(threading.Thread):
    delay = 60 # min delay between updates, in seconds
    sleep_time = 0.1 # so low to minimize delays between quit request and thread shutdown

    def __init__(self, config):
        threading.Thread.__init__(self)
        self.config = config
        self.request_time = 0
        self.response_time = 0
        self.have_news = False

        # Here we store all records.  Sometimes they vanish, this is a work-around.
        self.records = {}

    def run(self):
        print '%s started.' % self.__class__.__name__
        while not shutting_down:
            if self.request_time > self.response_time:
                url = self.get_url()
                print 'Refreshing feed: ' + url
                try:
                    count = 0
                    for item in feedparser.parse(fetch(url))['items']:
                        self.records[item['link']] = item
                        count += 1
                    print 'Found %u items in %s' % (count, url)
                    self.response_time = time.time() + self.delay
                    self.have_news = True
                except Exception, e:
                    print >>sys.stderr, u'Error updating feed: %s\n%s' % (e, traceback.format_exc(e))
            time.sleep(self.sleep_time)
        print '%s over.' % self.__class__.__name__

    def update(self):
        """Requests an update."""
        self.request_time = time.time()

    def get_records(self, only_if_ready=True):
        """Returns all records sorted by date."""
        if only_if_ready and not self.have_news:
            return None
        self.have_news = False
        return sorted(self.records.values(), key=lambda item: self.get_item_date(item))

    def get_item_date(self, item):
        return item['updated_parsed']

    def get_url(self):
        return 'http://search.twitter.com/search.atom?q=' + urllib.quote(self.config.get_twitter_search())


class PodcastClientThread(TwitterClientThread):
    delay = 600 # 10 minutes between updates

    def get_url(self):
        return 'http://www.tmradio.net/podcast.xml'


class BaseWindow(object):
    """Base class for all windows.

    Loads UI definition from data/ui/CLASS_NAME.ui, finds a top-level window
    named as that class and creates an instance.
    """
    def __init__(self):
        self.builder = self._get_builder(self.__class__.__name__)
        self.window = self.builder.get_object(self.__class__.__name__)
        self.builder.connect_signals(self)

    def _get_builder(self, name):
        builder = gtk.Builder()
        if sys.argv[0].startswith('/usr/bin'):
            dirname = '/usr/share/tmradio-client'
        else:
            dirname = os.path.join(os.path.dirname(sys.argv[0]), '..', 'data')
        builder.add_from_file(os.path.join(dirname, name + '.ui'))
        return builder


class MessageTextView(gtk.TextView):
    def __init__(self, parent, collapse_nicknames=False):
        gtk.TextView.__init__(self)
        self.url_tags = []
        self.url_map = {}
        self.set_property('pixels-above-lines', 4)
        self.set_property('wrap-mode', gtk.WRAP_WORD)
        self.set_property('indent', -20)
        self.set_property('can-focus', False)
        self.set_property('editable', False)
        self.connect('motion_notify_event', self.on_mouse_motion)

        # Scroll to last line.
        # http://www.daa.com.au/pipermail/pygtk/2009-January/016507.html
        parent.get_vadjustment().connect('value-changed', self.on_va_changed)
        parent.get_vadjustment().connect("changed", self.on_va_changed2)

        self.setup_tags()
        parent.add_with_viewport(self)
        self.show_all()

    def on_va_changed(self, vadjust):
        vadjust.need_scroll = abs(vadjust.value + vadjust.page_size - vadjust.upper) < vadjust.step_increment

    def on_va_changed2(self, vadjust):
        if not hasattr(vadjust, "need_scroll") or vadjust.need_scroll:
            vadjust.set_value(vadjust.upper-vadjust.page_size)
            vadjust.need_scroll = True

    def setup_tags(self):
        tt = self.get_buffer().get_tag_table()

        tag = gtk.TextTag('time')
        tag.set_property('foreground', 'gray')
        tt.add(tag)

        tag = gtk.TextTag('nick')
        tag.set_property('foreground', 'black')
        tag.set_property('weight', 800)
        tt.add(tag)

    def on_mouse_motion(self, widget, event, data=None):
        """Track mouse movement to change the cursor.
        
        http://www.daa.com.au/pipermail/pygtk/2004-December/009352.html
        """
        pointer = self.window.get_pointer()
        x, y, spam = self.window.get_pointer()
        x, y = self.window_to_buffer_coords(gtk.TEXT_WINDOW_TEXT, x, y)
        tags = self.get_iter_at_location(x, y).get_tags()

        cursor = None
        for tag in tags:
            if tag in self.url_tags:
                cursor = gtk.gdk.Cursor(gtk.gdk.HAND2)
        self.get_window(gtk.TEXT_WINDOW_TEXT).set_cursor(cursor)

        return False

    def on_link_event(self, tag, tv, event, iterator, link):
        link = link.rstrip(',.!?)')
        if self.url_map.has_key(link):
            link = self.url_map[link]
        if event.type == gtk.gdk.BUTTON_PRESS and event.button == 3:
            menu = gtk.Menu()
            item = gtk.MenuItem('Open link')
            item.connect('activate', lambda item: webbrowser.open(link))
            menu.append(item)
            menu.show_all()
            menu.popup(None, None, None, event.button, event.time)
            return True
        elif event.type == gtk.gdk.BUTTON_PRESS and event.button == 1:
            webbrowser.open(link)
            return True
        return False

    def add_message(self, **_kwargs):
        kwargs = {'time': datetime.datetime.now(), 'nick': None, 'nicklink': None, 'message': '' }
        kwargs.update(_kwargs)

        time = kwargs['time']
        nick = kwargs['nick']
        nicklink = kwargs['nicklink']
        text = kwargs['message'].strip()

        tb = self.get_buffer()
        sob, eob = tb.get_bounds()

        if tb.get_char_count():
            tb.insert(eob, '\n')

        tb.insert_with_tags_by_name(eob, time.strftime('%d.%m %H:%M '), 'time')
        self._add_nickname(tb, eob, kwargs)
        tb.insert(eob, ':')

        for word in text.split(' '):
            tb.insert(eob, ' ')
            if is_url(word):
                # http://www.mail-archive.com/pygtk@daa.com.au/msg18007.html
                t = tb.create_tag()
                t.set_property('foreground', 'blue')
                t.set_property('underline', pango.UNDERLINE_SINGLE)
                t.connect('event', self.on_link_event, word)
                tb.insert_with_tags(eob, word, t)
                self.url_tags.append(t)
            else:
                tb.insert(eob, word)

    def _add_nickname(self, tb, eob, kwargs):
        t = tb.create_tag()
        t.set_property('weight', 800)
        if kwargs['nicklink']:
            t.set_property('underline', pango.UNDERLINE_SINGLE)
            t.connect('event', self.on_link_event, kwargs['nick'])
            self.url_tags.append(t)
            self.url_map[kwargs['nick']] = kwargs['nicklink']
        tb.insert_with_tags(eob, kwargs['nick'], t)

    def clear(self):
        self.url_tags = []
        self.url_map = {}
        tb = self.get_buffer()
        sob, eob = tb.get_bounds()
        tb.delete(sob, eob)


MessageView = MessageTextView


class PodcastView(gtk.TreeView):
    def __init__(self, parent):
        gtk.TreeView.__init__(self)
        self._parent = parent
        self.episode_links = []
        self.model = gtk.ListStore(str, str, str, str, str, str) # date, title, size, page_link, file_link, ts
        self.setup()
        self.show_all()

    def setup(self):
        self.set_model(self.model)

        cell = gtk.CellRendererText()
        col = gtk.TreeViewColumn('Time', cell, text=0, resizable=True)
        col.set_property('resizable', True)
        self.append_column(col)

        cell = gtk.CellRendererText()
        cell.props.xalign = 0.0
        cell.props.ellipsize = pango.ELLIPSIZE_END
        col = gtk.TreeViewColumn('Title', cell, text=1)
        col.set_property('expand', True)
        col.set_property('resizable', True)
        col.set_property('sizing', gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        self.append_column(col)

        cell = gtk.CellRendererText()
        cell.props.xalign = 1.0
        col = gtk.TreeViewColumn('Size', cell, text=2, expand=False)
        col.set_property('resizable', True)
        self.append_column(col)

        self.connect('button-press-event', self.on_row_clicked)
        self._parent.add_with_viewport(self)

        self.model.set_sort_func(0, lambda model, iter1, iter2: cmp(model.get_value(iter1, 5), model.get_value(iter2, 5)))
        self.model.set_sort_column_id(0, gtk.SORT_DESCENDING)

    def add(self, date, title, link, audio_link, audio_size):
        if link not in self.episode_links:
            date_txt = time.strftime('%d.%m %H:%M', date)
            size_txt = u'%.1fM' % (audio_size / 1048576)

            model = self.get_model()
            row_iter = model.append([date_txt, title, size_txt, link, audio_link, time.strftime('%Y%m%d%H%M%S', date)])
            self.episode_links.append(link)
            # path = model.get_path(row_iter)
            # self.scroll_to_cell(path)

    def on_row_clicked(self, tv, event):
        path, column, rx, ry = tv.get_path_at_pos(int(event.x), int(event.y)) or (None,) * 4
        if path is not None:
            selection = tv.get_selection()
            model, paths = selection.get_selected_rows()

            page_link = model.get_value(model.get_iter(path), 3)
            file_link = model.get_value(model.get_iter(path), 4)

            if event.button == 3:
                menu = gtk.Menu()

                if page_link:
                    item = gtk.MenuItem('Open episode page')
                    item.connect('activate', lambda item: webbrowser.open(page_link))
                    menu.append(item)

                if file_link:
                    item = gtk.MenuItem('Download episode')
                    item.connect('activate', lambda item: webbrowser.open(file_link))
                    menu.append(item)

                menu.show_all()
                menu.popup(None, None, None, event.button, event.time)

            elif event.type == gtk.gdk._2BUTTON_PRESS:
                webbrowser.open(page_link)

    def on_column_resize(self, *args):
        print 'on_column_resize', args


class MainWindow(BaseWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.config = YamlConfig()
        self.jabber = Jabber(self)
        self.twitter = TwitterClientThread(self.config)
        self.podcast = PodcastClientThread(self.config)
        self.is_playing = False
        self.is_in_chat = False
        self.is_online = False # the bot is available
        self.is_visible = False
        # Track properties.
        self.track_id = None
        self.track_artist = None
        self.track_title = None
        self.track_labels = None
        self.track_labels_original = None # for editing
        self.track_length = None
        self.track_change_ts = None
        self.track_vote = 0
        self.track_link = None
        self.track_editable = False
        # Other windows.
        self.pref_window = None
        # Suppress duplicate nicknames in the chat window.
        self.last_chat_nick = None
        # Initialize the player.
        self.player = tmradio.audio.Open(on_track_change=self.on_stream_track_change, config=self.config)
        # RegExp for parsing stream title.
        self.stream_title_re = re.compile('"([^"]+)" by (.+)')

        self.window.connect('window-state-event', self.on_window_state)

        self.init_tabs()
        gobject.timeout_add(30, self.on_idle)

        settings = gtk.settings_get_default()
        settings.props.gtk_button_images = True

        self.twitter.start()
        self.podcast.start()
        self._jabber_autoconnect()

    def on_window_state(self, window, event):
        mask = gtk.gdk.WINDOW_STATE_ICONIFIED | gtk.gdk.WINDOW_STATE_WITHDRAWN
        self.is_visible = not (event.new_window_state & mask)

    def init_tabs(self):
        self.chat_tab = MessageView(self.builder.get_object('chatscroll'), collapse_nicknames=True)
        self.twit_tab = MessageView(self.builder.get_object('twitscroll'))
        self.cast_tab = PodcastView(self.builder.get_object('podscroll'))
        self.init_nicklist()

    def init_nicklist(self):
        tv = self.builder.get_object('userlist')
        tm = tv.get_model()

        cell = gtk.CellRendererText()
        col = gtk.TreeViewColumn('Nickname')
        col.pack_start(cell, True)
        col.add_attribute(cell, 'text', 0)
        col.set_sort_column_id(0)
        tv.append_column(col)

        tm.set_sort_func(0, lambda model, iter1, iter2: cmp(model.get_value(iter1, 0).lower(), model.get_value(iter2, 0).lower()))
        tm.set_sort_column_id(0, gtk.SORT_ASCENDING)

    def _jabber_autoconnect(self):
        """Connects to the jabber server if parameters are OK."""
        if self.config.get_jabber_id() and self.config.get_jabber_password():
            self.jabber.post_message('connect', special=True)
        else:
            self.on_menu_preferences_activate()

    def on_delete(self, *args):
        """Handle the main window's close button."""
        self.on_menu_quit_activate(None)

    def on_MainWindow_destroy(self, widget, data=None):
        self.jabber.post_message('quit', special=True)
        # gtk.main_quit()

    def on_play_clicked(self, widget, data=None):
        if self.is_playing:
            self.stop_playing()
        else:
            self.start_playing()

    def stop_playing(self):
        self.player.stop()
        self.builder.get_object('play').get_image().set_from_stock('gtk-media-play', gtk.ICON_SIZE_BUTTON)
        self.is_playing = False

    def start_playing(self):
        self.player.play(self.config.get_stream_uri(), volume=self.builder.get_object('volume').get_value())
        self.builder.get_object('play').get_image().set_from_stock('gtk-media-stop', gtk.ICON_SIZE_BUTTON)
        self.is_playing = True

    def set_track_info(self, artist, title, track_id, count, weight, tags, full_update):
        self.builder.get_object('track_artist').set_text(artist)
        self.builder.get_object('track_title').set_text(title)
        self.builder.get_object('track_labels').set_text(u' '.join(tags))
        if HAVE_NOTIFY and full_update and not self.is_visible:
            message = u'"%s" by %s' % (title, artist)
            if self.track_vote > 0:
                message += u'. You LOVE it.'
            elif self.track_vote < 0:
                message += u'. You HATE it.'
            print u'Notification: ' + message
            n = pynotify.Notification(self.window.get_title(), message, 'audio-volume-medium')
            n.set_urgency(pynotify.URGENCY_LOW)
            n.show()

    def on_stream_track_change(self, title):
        print 'Stream title changed.'
        m = self.stream_title_re.search(title)
        if m:
            print m.groups()

    def set_track_id(self, track_id):
        self.track_id = track_id

    def clear_chat(self):
        self.chat_tab.clear()

    def add_chat(self, text, nick=None, time=None):
        if text and text.strip():
            self.chat_tab.add_message(time=time, nick=nick or u'Robot', message=text)

    def on_idle(self):
        """Update controls, process xmpp messages.""" 
        self._process_jabber_replies()
        self._update_progress_bar()
        if not USE_THREADING:
            self.jabber.process_queue()
        if self.player:
            self.player.check_restart()
        self._update_twitter()
        self._update_podcast()
        return True

    def _update_progress_bar(self):
        if self.track_change_ts and self.track_length:
            spent = float(min(int(time.time()) - self.track_change_ts, self.track_length))
            fraction = spent / float(self.track_length)
        else:
            fraction = 0
        pb = self.builder.get_object('progress')
        if pb.get_fraction() != fraction:
            pb.set_fraction(fraction)

    def _is_online(self):
        return self.jabber and self.jabber.is_connected() and self.is_online

    def update_controls(self):
        """Disables and enables controls on conditions."""
        connected = self.jabber.is_connected()
        self.update_buttons()

        img = self.builder.get_object('chatbtn').get_image()
        img.set_from_stock(self.is_in_chat and gtk.STOCK_DISCONNECT or gtk.STOCK_CONNECT, gtk.ICON_SIZE_BUTTON)
        self.builder.get_object('chatbtn').set_sensitive(connected)
        self.builder.get_object('chatmsg').set_sensitive(self.is_in_chat and 1 or 0)

        for ctl_name in ('skip', 'track_artist', 'track_title', 'track_labels', 'update'):
            self.builder.get_object(ctl_name).set_sensitive(self.track_editable and connected and self.is_online)

    def _process_jabber_replies(self):
        """Process the incoming jabber message queue."""
        update_track_info = False
        update_controls = False
        full_update = False
        for replies in self.jabber.fetch_replies():
            if type(replies) != list:
                replies = [replies]
            for reply in replies:
                update_controls = True
                if reply[0] == 'set':
                    self.is_online = True
                    if self._process_jabber_property(reply):
                        full_update = True
                    update_track_info = True
                elif reply[0] == 'offline':
                    self.is_online = False
                elif reply[0] == 'chat':
                    self.is_online = True
                    timestamp = len(reply) > 3 and reply[3] or datetime.datetime.now()
                    self.add_chat(reply[1], reply[2], timestamp)
                elif reply[0] == 'joined':
                    self.is_online = True
                    self.is_in_chat = True
                elif reply[0] == 'left':
                    self.is_in_chat = False
                    self.chat_tab.clear()
                elif reply[0] == 'disconnected':
                    self.track_vote = 0
                elif reply[0] == 'join':
                    self.is_online = True
                    self._add_chat_user(reply[1], True)
                elif reply[0] == 'part':
                    self.is_online = True
                    self._add_chat_user(reply[1], False)
                elif reply[0] == 'auth-error':
                    self.on_menu_preferences_activate()
                else:
                    print u'Unhandled jabber reply:', reply
        if update_track_info:
            self.set_track_info(self.track_artist, self.track_title, self.track_id, 0, 0, self.track_labels, full_update)
            self.twitter.update()
            self.podcast.update()
        if update_controls:
            self.update_controls()

    def _update_twitter(self):
        items = self.twitter.get_records()
        if items:
            self.twit_tab.clear()
            for item in items:
                author = item['author'].split(' ')[0]
                tstamp = datetime.datetime.strptime(item['updated'], '%Y-%m-%dT%H:%M:%SZ')
                self.twit_tab.add_message(time=tstamp, nick=author, message=item['title'], nicklink=item['link'])

    def _update_podcast(self):
        items = self.podcast.get_records()
        if items:
            # self.twit_tab.clear()
            for item in items:
                if item.has_key('enclosures'):
                    audio_link = None
                    audio_size = None
                    for enc in item['enclosures']:
                        if enc.has_key('type') and enc['type'].startswith('audio/'):
                            audio_link = enc['href']
                            audio_size = enc.has_key('length') and int(enc['length']) or 1024
                    self.cast_tab.add(item['updated_parsed'], item['title'], item['link'], audio_link, audio_size)

    def _process_jabber_property(self, reply):
        key, value = reply[1:]
        if key == 'track_id':
            new_id = int(value)
            if new_id != self.track_id:
                # We use track chage time to display the progress bar, so it
                # needs to be precise.  If it's the first track info we get, it
                # most likely is mid-play, we're not interested.
                if self.track_id is not None:
                    self.track_change_ts = int(time.time())
                self.track_id = new_id
                self.track_vote = 0
        elif key == 'track_artist':
            self.track_artist = value
        elif key == 'track_title':
            self.track_title = value
        elif key == 'track_labels':
            self.track_labels = value
            self.track_labels_original = value
        elif key == 'track_length':
            self.track_length = int(value)
        elif key == 'track_started_on':
            if not self.track_change_ts and str(value).isdigit():
                self.track_change_ts = int(value)
        elif key == 'track_vote':
            self.track_vote = value and int(value) or 0
            return True
        elif key == 'track_editable':
            self.track_editable = value
        elif key == 'track_listeners':
            title = 'tmradio.net (%u)' % value
            self.window.set_title(title)
            self.builder.get_object('tray').set_tooltip(title)
        elif key == 'track_weight':
            pass
        elif key == 'track_playcount':
            pass
        else:
            print u'Unhandled property:', reply

        if key in ('track_title', 'track_artist', 'track_length'):
            text = u'%s — %s' % (self.track_artist, self.track_title)
            if self.track_length:
                text += u' [%u:%02u]' % (self.track_length / 60, self.track_length % 60)
            self.builder.get_object('progress').set_text(text)

    def _add_chat_user(self, name, joined=True):
        model = self.builder.get_object('nicklist')
        for iter in model:
            if iter[0] == name:
                model.remove(iter.iter)
        if joined:
            model.append([name])

    def on_rocks_toggled(self, button):
        return self.change_track_vote(button, 1)

    def on_sucks_toggled(self, button):
        return self.change_track_vote(button, -1)

    def change_track_vote(self, button, vote):
        """Changes the current track vote and updates the buttons.

        The vote is only changed is the button is pressed, not unpressed (the
        TriggerButton widget reports a toggle event even when the state is
        changed programmatically, tricks are used to detect the real
        situation)."""
        if button.get_active() and self.track_id and self.is_online:
            if self.track_vote != vote:
                self.track_vote = vote
                cmd = vote > 0 and 'rocks' or 'sucks'
                self.jabber.post_message('%u %s' % (self.track_id, cmd))
        self.update_buttons()

    def update_buttons(self):
        """Updates the rocks/sucks button states according to the current vote.

        If the bot is offline, buttons are unpressed and disabled, otherwise
        they're set according to the vote."""
        rocks = self.builder.get_object('rocks')
        sucks = self.builder.get_object('sucks')

        if self.is_online and self.track_id:
            rocks.set_active(self.track_vote > 0)
            sucks.set_active(self.track_vote < 0)

            rocks.set_sensitive(self.track_vote <= 0)
            sucks.set_sensitive(self.track_vote >= 0)
        else:
            rocks.set_active(False)
            rocks.set_sensitive(False)
            sucks.set_active(False)
            sucks.set_sensitive(False)

    def on_chatmsg_activate(self, field):
        if self.jabber:
            text = field.get_text()
            chat = not text.startswith('/')
            if not chat:
                text = text[1:]
            field.set_text('')
            self.jabber.post_message(text, chat=chat)

    def on_update_clicked(self, button):
        if not self.jabber:
            return # TODO: error message or else.
        fmap = { 'track_artist': 'set artist to %s for %u', 'track_title': 'set title to %s for %u', 'track_labels': 'tags %s for %u' }
        for key in fmap.keys():
            value = self.builder.get_object(key).get_text()
            if key == 'track_labels':
                current = value.split(' ')
                value = []
                for l in [x for x in current if x not in self.track_labels_original]:
                    value.append(l)
                for l in [x for x in self.track_labels_original if x not in current]:
                    value.append(u'-' + l)
                value = u' '.join(value)
            self.jabber.post_message(fmap[key] % (value, self.track_id))
        self.jabber.post_message('show ' + str(self.track_id))

    def on_chatbtn_clicked(self, *args):
        if self.is_in_chat:
            self.jabber.post_message('leave', special=True)
        else:
            self.jabber.post_message('join', special=True)

    def on_skip_clicked(self, button):
        self.jabber.post_message('skip')

    def on_info_clicked(self, *args):
        webbrowser.open('http://www.last.fm/music/%s' % urllib.quote(self.track_artist.encode('utf-8')))

    def on_volume_changed(self, widget, level):
        self.player.set_volume(level)

    def on_tray_activate(self, *args):
        if self.window.get_visible():
            self.window.hide()
        else:
            self.window.show()

    def on_tray_scroll(self, icon, event):
        delta = 0.1
        if event.direction == gtk.gdk.SCROLL_DOWN:
            delta = -0.1
        volume = self.builder.get_object('volume')
        value = min(max(volume.get_value() + delta, 0.0), 1.0)
        volume.set_value(value)

    def on_tray_menu(self, icon, *args):
        self.builder.get_object('tray_menu').popup(None, None, None, 3, 0)

    def on_tray_show(self, *args):
        self.on_tray_activate()

    def on_menu_preferences_activate(self, item=None):
        if not self.pref_window:
            self.pref_window = Preferences(self)
        self.pref_window.window.show()

    def on_menu_quit_activate(self, item):
        global shutting_down
        shutting_down = True
        gtk.main_quit()

    def on_menu_about_activate(self, *args):
        webbrowser.open('http://app.tmradio.net/')

    def on_menu_website_activate(self, *args):
        webbrowser.open('http://www.tmradio.net/')

    def on_menu_bugs_activate(self, *args):
        webbrowser.open('https://github.com/tmradio/tmradio-client-gtk/issues')

    def on_chat_entered(self):
        self.builder.get_object('chatmsg').grab_focus()

    def on_chat_left(self):
        self.clear_chat()


class Preferences(BaseWindow):
    def __init__(self, main):
        super(self.__class__, self).__init__()
        self.main = main
        self.config = main.config

    def on_delete(self, *args):
        self.window.hide()
        self.save()
        return True

    def on_show(self, *args):
        self.load()

    def on_close_clicked(self, *args):
        self.on_delete(*args)

    def load(self):
        """Fills form fields with config options."""
        for fn in [fn for fn in dir(self.config) if fn.startswith('get_')]:
            ctl = self.builder.get_object(fn[4:])
            if ctl:
                ctl.set_text(getattr(self.config, fn)() or '')

    def save(self):
        for fn in [fn for fn in dir(self.config) if fn.startswith('set_')]:
            ctl = self.builder.get_object(fn[4:])
            if ctl:
                getattr(self.config, fn)(ctl.get_text())
        self.config.save()
        self.main.jabber.post_message('connect', special=True)


if __name__ == '__main__':
    gobject.threads_init()
    app = MainWindow()
    app.window.show()
    if app.pref_window:
        app.pref_window.window.present()
    try:
        gtk.main()
    except KeyboardInterrupt:
        print >>sys.stderr, 'Shutting down.'
        shutting_down = True
